-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A family of combinators for defining webservices APIs and serving them
--   
@package servant-server
@version 0.2.1


-- | This module lets you implement <a>Server</a>s for defined APIs. You'll
--   most likely just need <a>serve</a>.
module Servant.Server

-- | <a>serve</a> allows you to implement an API and produce a wai
--   <a>Application</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   
--   app :: Application
--   app = serve myApi server
--   
--   main :: IO ()
--   main = Network.Wai.Handler.Warp.run 8080 app
--   </pre>
serve :: HasServer layout => Proxy layout -> Server layout -> Application
class HasServer layout where type family Server layout :: *
route :: HasServer layout => Proxy layout -> Server layout -> RoutingApplication
toApplication :: RoutingApplication -> Application
data RouteMismatch

-- | the usual "not found" error
NotFound :: RouteMismatch

-- | a more informative "you just got the HTTP method wrong" error
WrongMethod :: RouteMismatch

-- | an even more informative "your json request body wasn't valid" error
InvalidBody :: RouteMismatch

-- | <pre>
--   &gt; mempty = NotFound
--   &gt;
--   &gt; NotFound    <a>mappend</a>           x = x
--   &gt; WrongMethod <a>mappend</a> InvalidBody = InvalidBody
--   &gt; WrongMethod <a>mappend</a>           _ = WrongMethod
--   &gt; InvalidBody <a>mappend</a>           _ = InvalidBody
--   </pre>

-- | A wrapper around <tt><a>Either</a> <a>RouteMismatch</a> a</tt>.
newtype RouteResult a
RR :: Either RouteMismatch a -> RouteResult a
routeResult :: RouteResult a -> Either RouteMismatch a
failWith :: RouteMismatch -> RouteResult a
succeedWith :: a -> RouteResult a
isMismatch :: RouteResult a -> Bool

-- | If we get a <a>Right</a>, it has precedence over everything else.
--   
--   This in particular means that if we could get several <a>Right</a>s,
--   only the first we encounter would be taken into account.
type RoutingApplication = Request -> (RouteResult Response -> IO ResponseReceived) -> IO ResponseReceived
class HasServer layout where type family Server layout :: *
route :: HasServer layout => Proxy layout -> Server layout -> RoutingApplication

-- | A server for <tt>a <a>:&lt;|&gt;</a> b</tt> first tries to match the
--   request again the route represented by <tt>a</tt> and if it fails
--   tries <tt>b</tt>. You must provide a request handler for each route.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   </pre>
captured :: FromText a => proxy (Capture sym a) -> Text -> Maybe a

-- | If you use <a>Capture</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by the <a>Capture</a>. This
--   lets servant worry about getting it from the URL and turning it into a
--   value of the type you specify.
--   
--   You can control how it'll be converted from <a>Text</a> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get Book
--   
--   server :: Server MyApi
--   server = getBook
--     where getBook :: Text -&gt; EitherT (Int, String) IO Book
--           getBook isbn = ...
--   </pre>

-- | If you have a <a>Delete</a> endpoint in your API, the handler for this
--   endpoint is meant to delete a resource.
--   
--   The code of the handler will, just like for <a>Get</a>, <a>Post</a>
--   and <a>Put</a>, run in <tt>EitherT (Int, String) IO ()</tt>. The
--   <a>Int</a> represents the status code and the <a>String</a> a message
--   to be returned. You can use <a>left</a> to painlessly error out if the
--   conditions for a successful deletion are not met.

-- | When implementing the handler for a <a>Get</a> endpoint, just like for
--   <a>Delete</a>, <a>Post</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 200 along the way.

-- | If you use <a>Header</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by <a>Header</a>. This lets
--   servant worry about extracting it from the request and turning it into
--   a value of the type you specify.
--   
--   All it asks is for a <a>FromText</a> instance.
--   
--   Example:
--   
--   <pre>
--   newtype Referer = Referer Text
--     deriving (Eq, Show, FromText, ToText)
--   
--              -- GET /view-my-referer
--   type MyApi = "view-my-referer" :&gt; Header "Referer" Referer :&gt; Get Referer
--   
--   server :: Server MyApi
--   server = viewReferer
--     where viewReferer :: Referer -&gt; EitherT (Int, String) IO referer
--           viewReferer referer = return referer
--   </pre>

-- | When implementing the handler for a <a>Post</a> endpoint, just like
--   for <a>Delete</a>, <a>Get</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 201 along the way.

-- | When implementing the handler for a <a>Put</a> endpoint, just like for
--   <a>Delete</a>, <a>Get</a> and <a>Post</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 200 along the way.

-- | If you use <tt><a>QueryParam</a> "author" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt><a>Maybe</a> <a>Text</a></tt>.
--   
--   This lets servant worry about looking it up in the query string and
--   turning it into a value of the type you specify, enclosed in
--   <a>Maybe</a>, because it may not be there and servant would then hand
--   you <a>Nothing</a>.
--   
--   You can control how it'll be converted from <a>Text</a> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: Maybe Text -&gt; EitherT (Int, String) IO [Book]
--           getBooksBy Nothing       = ...return all books...
--           getBooksBy (Just author) = ...return books by the given author...
--   </pre>

-- | If you use <tt><a>QueryParams</a> "authors" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt>[<a>Text</a>]</tt>.
--   
--   This lets servant worry about looking up 0 or more values in the query
--   string associated to <tt>authors</tt> and turning each of them into a
--   value of the type you specify.
--   
--   You can control how the individual values are converted from
--   <a>Text</a> to your type by simply providing an instance of
--   <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: [Text] -&gt; EitherT (Int, String) IO [Book]
--           getBooksBy authors = ...return all books by these authors...
--   </pre>

-- | If you use <tt><a>QueryFlag</a> "published"</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type <a>Bool</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooks
--     where getBooks :: Bool -&gt; EitherT (Int, String) IO [Book]
--           getBooks onlyPublished = ...return all books, or only the ones that are already published, depending on the argument...
--   </pre>

-- | Just pass the request to the underlying application and serve its
--   response.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "images" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectory "/var/www/images"
--   </pre>

-- | If you use <a>ReqBody</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by <a>ReqBody</a>. This lets
--   servant worry about extracting it from the request and turning it into
--   a value of the type you specify.
--   
--   All it asks is for a <a>FromJSON</a> instance.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; ReqBody Book :&gt; Post Book
--   
--   server :: Server MyApi
--   server = postBook
--     where postBook :: Book -&gt; EitherT (Int, String) IO Book
--           postBook book = ...insert into your db...
--   </pre>

-- | Make sure the incoming request starts with <tt>"/path"</tt>, strip it
--   and pass the rest of the request path to <tt>sublayout</tt>.


-- | This module defines a sever-side handler that lets you serve static
--   files.
--   
--   <ul>
--   <li><a>serveDirectory</a> lets you serve anything that lives under a
--   particular directory on your filesystem.</li>
--   </ul>
module Servant.Utils.StaticFiles

-- | Serve anything under the specified directory as a <a>Raw</a> endpoint.
--   
--   <pre>
--   type MyApi = "static" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectory "/var/www"
--   </pre>
--   
--   would capture any request to <tt>/static/&lt;something&gt;</tt> and
--   look for <tt>&lt;something&gt;</tt> under <tt>/var/www</tt>.
--   
--   It will do its best to guess the MIME type for that file, based on the
--   extension, and send an appropriate <i>Content-Type</i> header if
--   possible.
--   
--   If your goal is to serve HTML, CSS and Javascript files that use the
--   rest of the API as a webapp backend, you will most likely not want the
--   static files to be hidden behind a <i>/static/</i> prefix. In that
--   case, remember to put the <a>serveDirectory</a> handler in the last
--   position, because <i>servant</i> will try to match the handlers in
--   order.
serveDirectory :: FilePath -> Server Raw

module Servant

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
